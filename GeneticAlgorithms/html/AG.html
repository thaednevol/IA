
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>ALGORITMOS GENETICOS</title><meta name="generator" content="MATLAB 9.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-06-12"><meta name="DC.source" content="AG.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>ALGORITMOS GENETICOS</h1><!--introduction--><p>Los algoritmos gen&eacute;ticos son una de las mejores maneras de resolver un problema para el cual poco se sabe. Son un algoritmo muy general y por lo tanto funcionar&aacute; bien en cualquier espacio de b&uacute;squeda. Todo lo que necesita saber es lo que necesita la soluci&oacute;n para poder hacerlo bien, y un algoritmo gen&eacute;tico ser&aacute; capaz de crear una soluci&oacute;n de alta calidad. Los algoritmos gen&eacute;ticos utilizan los principios de selecci&oacute;n y evoluci&oacute;n para producir varias soluciones a un problema dado.</p><p>Los algoritmos gen&eacute;ticos tienden a prosperar en un entorno en el que hay un conjunto muy grande de soluciones candidatas y en el que el espacio de b&uacute;squeda es desigual y tiene muchas colinas y valles. Es cierto que los algoritmos gen&eacute;ticos funcionar&aacute;n bien en cualquier entorno, pero ser&aacute;n superados por m&aacute;s algoritmos espec&iacute;ficos de la situaci&oacute;n en los espacios de b&uacute;squeda m&aacute;s simples. Por lo tanto, se debe tener en cuenta que los algoritmos gen&eacute;ticos no siempre son la mejor opci&oacute;n. A veces pueden tomar bastante tiempo para correr y por lo tanto no siempre es factible para el uso en tiempo real. Sin embargo, son uno de los m&eacute;todos m&aacute;s poderosos con los que (relativamente) se pueden crear r&aacute;pidamente soluciones de alta calidad a un problema.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Problema</a></li><li><a href="#3">Soluci&oacute;n</a></li><li><a href="#5">1) Ingreso de variables</a></li><li><a href="#6">2) C&aacute;lculo de variables a usar</a></li><li><a href="#8">3) Creaci&oacute;n de poblaci&oacute;n inicial</a></li><li><a href="#10">4) Creaci&oacute;n de padres</a></li><li><a href="#12">5) Tranformaci&oacute;n de variables</a></li><li><a href="#14">6) Evaluaci&oacute;n de la funci&oacute;n objetivo</a></li><li><a href="#16">7) C&aacute;lculo la aptitud total de la poblaci&oacute;n</a></li><li><a href="#18">8) C&aacute;lculo las probabilidades de cada cromosoma</a></li><li><a href="#20">9) C&aacute;lculo de las probabilidades acumuladas</a></li><li><a href="#22">10) Primer procedimiento de seleccion</a></li><li><a href="#26">11) Procedimiento de cruce</a></li><li><a href="#30">12) Mutaci&oacute;n</a></li><li><a href="#32">13) Segunda selecci&oacute;n</a></li><li><a href="#34">13) Repetici&oacute;n</a></li><li><a href="#35">Resultado</a></li><li><a href="#37">Conclusiones</a></li></ul></div><h2 id="1">Problema</h2><p>Se requiere realizar la implementaci&oacute;n de un algoritmo que permita encontrar el m&aacute;ximo valor para una funci&oacute;n dada, la cual depende de 2 variables</p><h2 id="3">Soluci&oacute;n</h2><p>Se implementar&aacute; un algoritmo gen&eacute;tico el cual se describir&aacute; a continuaci&oacute;n:</p><h2 id="5">1) Ingreso de variables</h2><p>Se ingresan las variables. (Para facilidad, se encuentran ya establecidas)</p><pre class="codeinput"><span class="comment">%numero_variables=input('Digite el numero de variables');</span>
numero_variables=2;
<span class="comment">%numero_generaciones=input('Digite el numero de generaciones');</span>
numero_generaciones=300;
<span class="comment">%precision=input('Digite la precision');</span>
precision=5;
<span class="comment">%numero_poblacion_inicial=input('Digite la poblacion inicial');</span>
numero_poblacion_inicial=100;
<span class="comment">%pc==input('Ingrese la rata de cruce');</span>
pc=0.5;
<span class="comment">%pm==input('Ingrese la rata de mutaci&oacute;n');</span>
pm=0.01;

<span class="comment">%tamano_cromosomas=0;</span>
<span class="comment">% for i=1:numero_variables</span>
<span class="comment">%     variables(i,1)=input('Digite el limite inferior');</span>
<span class="comment">%     variables(i,2)=input('Digite el limite superior');</span>
<span class="comment">%     variables(i,3)=floor(log2((variables(i,2)-variables(i,1))*10^precision)+1);</span>
<span class="comment">%     tamano_cromosomas=tamano_cromosomas+variables(i,3);</span>
<span class="comment">% end</span>

variables(1,1)=-3;
variables(1,2)=12.1;

variables(2,1)=4.1;
variables(2,2)=5.8;
</pre><h2 id="6">2) C&aacute;lculo de variables a usar</h2><p>Se calculan los tama&ntilde;os de las variables a usar</p><pre class="codeinput"><span class="comment">%El resultado del siguiente procedimiento es 21</span>
variables(1,3)=floor(log2(( variables(1,2) - variables(1,1) )*10^precision)+1);

<span class="comment">%El resultado del siguiente procedimiento es 18</span>
variables(2,3)=floor(log2((variables(2,2)-variables(2,1))*10^precision)+1);
<span class="comment">%El resultado del siguiente procedimiento es 39</span>
tamano_cromosomas=variables(1,3)+variables(2,3);
</pre><h2 id="8">3) Creaci&oacute;n de poblaci&oacute;n inicial</h2><pre class="codeinput">poblacion_inicial=round(rand(numero_poblacion_inicial,tamano_cromosomas));
</pre><h2 id="10">4) Creaci&oacute;n de padres</h2><p>Se seleccionan las dos porciones para la generacion de los dos X</p><pre class="codeinput">X1=poblacion_inicial(:,1:variables(1,3));
X2=poblacion_inicial(:,variables(1,3)+1:tamano_cromosomas);
</pre><h2 id="12">5) Tranformaci&oacute;n de variables</h2><p>Se generan las palabras para cada fila: X transformado fila binaria a celda decimal</p><pre class="codeinput"><span class="comment">%Fila binaria a celda binaria</span>
X1b=FilBin2CelBin(X1);
X2b=FilBin2CelBin(X2);
<span class="comment">%Fila binaria a celda decimal</span>
X1t=FilBin2CelDec(X1);
X2t=FilBin2CelDec(X2);
<span class="comment">%X real</span>
<span class="comment">%Celda decimal a numero real</span>
X1r=CelDec2NumRea(variables(1,1), variables(1,2), variables(1,3) , X1t);
X2r=CelDec2NumRea(variables(2,1), variables(2,2), variables(2,3) , X2t);
<span class="comment">%Geracion de V binario</span>
Vb=GenVb(X1b,X2b);
<span class="comment">%Generacion de V real</span>
V=GenVr(X1r,X2r);
</pre><h2 id="14">6) Evaluaci&oacute;n de la funci&oacute;n objetivo</h2><p>Se eval&uacute;a: 21.5+x1*sin(4*pi*x1) + sin(20*pi*x2), mediante: 21.5+V(i,1)*sin(4*pi*V(i,1)) + sin(20*pi*V(i,2));</p><pre class="codeinput">E=funcionObjetivo(V);
</pre><h2 id="16">7) C&aacute;lculo la aptitud total de la poblaci&oacute;n</h2><pre class="codeinput">ATP=0;
<span class="keyword">for</span> i=1:length(E)
    ATP=E(i) + ATP;
<span class="keyword">end</span>
</pre><h2 id="18">8) C&aacute;lculo las probabilidades de cada cromosoma</h2><pre class="codeinput">p=zeros(length(E),1);
<span class="keyword">for</span> i=1:length(E)
    p(i,:)=E(i)/ATP;
<span class="keyword">end</span>
</pre><h2 id="20">9) C&aacute;lculo de las probabilidades acumuladas</h2><pre class="codeinput">qa=0;
q=zeros(length(p),1);

<span class="keyword">for</span> i=1:length(p)
    qa=qa+p(i);
    q(i,:)=qa;
<span class="keyword">end</span>
</pre><h2 id="22">10) Primer procedimiento de seleccion</h2><div><ul><li>Se genera r numeros aleatorios</li></ul></div><pre class="codeinput">r=rand(numero_poblacion_inicial,1);
</pre><div><ul><li>Seleccion de cromosomas</li></ul></div><pre class="codeinput">Vn=zeros(length(q),1);
<span class="keyword">for</span> i=1:length(q)
    <span class="keyword">if</span> r(i)&lt;=q(i)
        Vn(i,:)=V(1);
    <span class="keyword">else</span>
        Vn(i,:)=V(i);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2 id="26">11) Procedimiento de cruce</h2><div><ul><li>Se seleccionan los padres.</li></ul></div><pre class="codeinput">k=1;
padre_temp=Vb;

<span class="keyword">for</span> i=1:length(Vn)
    <span class="comment">%Es una de las formas que se encontr&oacute; para generar n&uacute;meros aleatrorios en el rango</span>
    <span class="comment">%r = min(p) + (max(p)-min(p)).*rand;</span>
    r=rand;
    <span class="keyword">if</span> r&lt;pc
        padre_temp(k,:)=Vb(i,:);
        k=k+1;
    <span class="keyword">end</span>
<span class="keyword">end</span>

padre=padre_temp(1:k-1,:);
</pre><div><ul><li>Se genera una matriz de n&uacute;meros aleatorios enteros entre [2 , No de bits -1]</li></ul></div><pre class="codeinput">r=randi([2 tamano_cromosomas-1],numero_poblacion_inicial,1);

i=1;
Vh=zeros(numero_poblacion_inicial,tamano_cromosomas);
<span class="keyword">while</span> i&lt;numero_poblacion_inicial
    rl=r(i);
    [padre1,padre2]=traerPareja(padre);
    p1=padre1(1:rl);
    p2=padre2(rl+1:end);
    Vh(i,:)=[p1 p2];
    p3=padre1(rl+1:end);
    p4=padre2(1:rl);
    Vh(i+1,:)=[p3 p4];
    i=i+1;
<span class="keyword">end</span>
</pre><h2 id="30">12) Mutaci&oacute;n</h2><p>Se vuelve a generar una matriz de n&uacute;meros aleatorios, que serviran para evaluar la probabilidad</p><pre class="codeinput">r=rand(tamano_cromosomas*length(Vh),1);
contador=0;
<span class="keyword">for</span> k=1:length(r)
    <span class="keyword">if</span> r(k)&lt;pm
        Vh=mutar(Vh,k);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2 id="32">13) Segunda selecci&oacute;n</h2><p>La segunda selecci&oacute;n se har&aacute; por torneo y se seleccionan los mejores</p><pre class="codeinput">PobTot=[Vh;BinChar2BinVect(padre)];
p1=FilBin2NumRea(variables(1,1), variables(1,2), variables(1,3),PobTot(:,1:variables(1,3)));
p2=FilBin2NumRea(variables(2,1), variables(2,2), variables(2,3),PobTot(:,variables(1,3)+1:tamano_cromosomas));
V=GenVr(p1,p2);
FO=funcionObjetivo(V);
FOi=zeros(size(FO,1),2);
<span class="keyword">for</span> i=1:size(FO,1)
    FOi(i,1)=FO(i);
    FOi(i,2)=i;
<span class="keyword">end</span>
FOi=FOi';
[y1,I] = sort(FOi(1,:));
index=I(end-numero_poblacion_inicial:end);
<span class="keyword">for</span> k=size(index,2)-1:-1:1
    Vh(k,:)=PobTot(index(k),:);
<span class="keyword">end</span>

maximo=0;
j=0;
</pre><h2 id="34">13) Repetici&oacute;n</h2><p>Se repite el algoritmo tantas generaciones como las que se ingresaron</p><pre class="codeinput"><span class="keyword">for</span> i=1:numero_generaciones
    [Vh,E,ATP,V]=myAG(Vh,variables,tamano_cromosomas,numero_poblacion_inicial,pc,pm);
<span class="keyword">end</span>
</pre><h2 id="35">Resultado</h2><pre class="codeinput">max(E(:))
</pre><pre class="codeoutput">
ans =

   34.1241

</pre><h2 id="37">Conclusiones</h2><div><ol><li>El proceso para solucionar el problema fue un tanto r&aacute;pido debido a que no era complejo.</li><li>En la medida en la que se agregan m&aacute;s padres, da una soluci&oacute;n mas &oacute;ptima, pero m&aacute;s lenta</li><li>Se puede variar las probabilidades para encontrar soluciones no tan precisas pero si m&aacute;s r&aacute;pidas</li></ol></div><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016b</a><br></p></div><!--
##### SOURCE BEGIN #####
%%  ALGORITMOS GENETICOS
% Los algoritmos genéticos son una de las mejores maneras de resolver un problema para el cual poco se sabe. Son un algoritmo muy
% general y por lo tanto funcionará bien en cualquier espacio de búsqueda. Todo lo que necesita saber es lo que necesita la
% solución para poder hacerlo bien, y un algoritmo genético será capaz de crear una solución de alta calidad. Los algoritmos
% genéticos utilizan los principios de selección y evolución para producir varias soluciones a un problema dado.
%
% Los algoritmos genéticos tienden a prosperar en un entorno en el que hay un conjunto muy grande de soluciones candidatas y en el
% que el espacio de búsqueda es desigual y tiene muchas colinas y valles. Es cierto que los algoritmos genéticos funcionarán bien
% en cualquier entorno, pero serán superados por más algoritmos específicos de la situación en los espacios de búsqueda más
% simples. Por lo tanto, se debe tener en cuenta que los algoritmos genéticos no siempre son la mejor opción. A veces pueden tomar
% bastante tiempo para correr y por lo tanto no siempre es factible para el uso en tiempo real. Sin embargo, son uno de los
% métodos más poderosos con los que (relativamente) se pueden crear rápidamente soluciones de alta calidad a un problema. 
%
%%

%% Problema
% Se requiere realizar la implementación de un algoritmo que permita encontrar el máximo valor para una función dada, la cual
% depende de 2 variables
%%

%% Solución
% Se implementará un algoritmo genético el cual se describirá a continuación:
%%

%% 1) Ingreso de variables
% Se ingresan las variables. (Para facilidad, se encuentran ya establecidas)
%numero_variables=input('Digite el numero de variables');
numero_variables=2;
%numero_generaciones=input('Digite el numero de generaciones');
numero_generaciones=300;
%precision=input('Digite la precision');
precision=5;
%numero_poblacion_inicial=input('Digite la poblacion inicial');
numero_poblacion_inicial=100;
%pc==input('Ingrese la rata de cruce');
pc=0.5;
%pm==input('Ingrese la rata de mutación');
pm=0.01;

%tamano_cromosomas=0;
% for i=1:numero_variables
%     variables(i,1)=input('Digite el limite inferior');
%     variables(i,2)=input('Digite el limite superior');
%     variables(i,3)=floor(log2((variables(i,2)-variables(i,1))*10^precision)+1);
%     tamano_cromosomas=tamano_cromosomas+variables(i,3);
% end

variables(1,1)=-3;
variables(1,2)=12.1;

variables(2,1)=4.1;
variables(2,2)=5.8;
%% 2) Cálculo de variables a usar
% Se calculan los tamaños de las variables a usar
%%
%El resultado del siguiente procedimiento es 21
variables(1,3)=floor(log2(( variables(1,2) - variables(1,1) )*10^precision)+1);

%El resultado del siguiente procedimiento es 18
variables(2,3)=floor(log2((variables(2,2)-variables(2,1))*10^precision)+1);
%El resultado del siguiente procedimiento es 39
tamano_cromosomas=variables(1,3)+variables(2,3);

%% 3) Creación de población inicial
%%
poblacion_inicial=round(rand(numero_poblacion_inicial,tamano_cromosomas));
%% 4) Creación de padres
% Se seleccionan las dos porciones para la generacion de los dos X 
%%
X1=poblacion_inicial(:,1:variables(1,3));
X2=poblacion_inicial(:,variables(1,3)+1:tamano_cromosomas);
%% 5) Tranformación de variables
% Se generan las palabras para cada fila: X transformado fila binaria a celda decimal
%%
%Fila binaria a celda binaria
X1b=FilBin2CelBin(X1);
X2b=FilBin2CelBin(X2);
%Fila binaria a celda decimal
X1t=FilBin2CelDec(X1);
X2t=FilBin2CelDec(X2);
%X real
%Celda decimal a numero real
X1r=CelDec2NumRea(variables(1,1), variables(1,2), variables(1,3) , X1t);
X2r=CelDec2NumRea(variables(2,1), variables(2,2), variables(2,3) , X2t);
%Geracion de V binario
Vb=GenVb(X1b,X2b);
%Generacion de V real
V=GenVr(X1r,X2r);
%% 6) Evaluación de la función objetivo
% Se evalúa: 21.5+x1*sin(4*pi*x1) + sin(20*pi*x2), mediante:
% 21.5+V(i,1)*sin(4*pi*V(i,1)) + sin(20*pi*V(i,2));
%%
E=funcionObjetivo(V);

%% 7) Cálculo la aptitud total de la población
%%
ATP=0;
for i=1:length(E)
    ATP=E(i) + ATP;
end
%% 8) Cálculo las probabilidades de cada cromosoma
%%
p=zeros(length(E),1);
for i=1:length(E)
    p(i,:)=E(i)/ATP;
end
%% 9) Cálculo de las probabilidades acumuladas
%%
qa=0;
q=zeros(length(p),1);

for i=1:length(p)
    qa=qa+p(i);
    q(i,:)=qa;
end

%% 10) Primer procedimiento de seleccion
%
% * Se genera r numeros aleatorios
%%
r=rand(numero_poblacion_inicial,1);
%%
% * Seleccion de cromosomas
%%
Vn=zeros(length(q),1);
for i=1:length(q)
    if r(i)<=q(i)
        Vn(i,:)=V(1);
    else
        Vn(i,:)=V(i);
    end
end

%%  11) Procedimiento de cruce
% * Se seleccionan los padres.
%%
k=1;
padre_temp=Vb;

for i=1:length(Vn)
    %Es una de las formas que se encontró para generar números aleatrorios en el rango
    %r = min(p) + (max(p)-min(p)).*rand;
    r=rand;
    if r<pc
        padre_temp(k,:)=Vb(i,:);
        k=k+1;
    end
end

padre=padre_temp(1:k-1,:);
%%
% * Se genera una matriz de números aleatorios enteros entre [2 , No de bits -1]
%%
r=randi([2 tamano_cromosomas-1],numero_poblacion_inicial,1);

i=1;
Vh=zeros(numero_poblacion_inicial,tamano_cromosomas);
while i<numero_poblacion_inicial
    rl=r(i);
    [padre1,padre2]=traerPareja(padre);
    p1=padre1(1:rl);
    p2=padre2(rl+1:end);
    Vh(i,:)=[p1 p2];
    p3=padre1(rl+1:end);
    p4=padre2(1:rl);
    Vh(i+1,:)=[p3 p4];
    i=i+1;
end

%% 12) Mutación
% Se vuelve a generar una matriz de números aleatorios, que serviran para evaluar la probabilidad
%%
r=rand(tamano_cromosomas*length(Vh),1);
contador=0;
for k=1:length(r)
    if r(k)<pm
        Vh=mutar(Vh,k);
    end
end

%% 13) Segunda selección
% La segunda selección se hará por torneo y se seleccionan los mejores
%%
PobTot=[Vh;BinChar2BinVect(padre)];
p1=FilBin2NumRea(variables(1,1), variables(1,2), variables(1,3),PobTot(:,1:variables(1,3)));
p2=FilBin2NumRea(variables(2,1), variables(2,2), variables(2,3),PobTot(:,variables(1,3)+1:tamano_cromosomas));
V=GenVr(p1,p2);
FO=funcionObjetivo(V);
FOi=zeros(size(FO,1),2);
for i=1:size(FO,1)
    FOi(i,1)=FO(i);
    FOi(i,2)=i;
end
FOi=FOi';
[y1,I] = sort(FOi(1,:));
index=I(end-numero_poblacion_inicial:end);
for k=size(index,2)-1:-1:1
    Vh(k,:)=PobTot(index(k),:);
end
    
maximo=0;
j=0;


%% 13) Repetición
% Se repite el algoritmo tantas generaciones como las que se ingresaron
for i=1:numero_generaciones
    [Vh,E,ATP,V]=myAG(Vh,variables,tamano_cromosomas,numero_poblacion_inicial,pc,pm);
end

%% Resultado
%
%%
max(E(:))

%% Conclusiones
% # El proceso para solucionar el problema fue un tanto rápido debido a que no era complejo.
% # En la medida en la que se agregan más padres, da una solución mas óptima, pero más lenta
% # Se puede variar las probabilidades para encontrar soluciones no tan precisas pero si más rápidas
##### SOURCE END #####
--></body></html>